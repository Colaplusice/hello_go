# leetcode go

## 258 各位相加

你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？

结果只可能是0-9之间的数，那么结果是哪个呢，取余9

## 最大的值
const MaxUint = ^uint(0)
const MinUint = 0
const MaxInt = int(MaxUint >> 1)
const MinInt = -MaxInt - 1

## 11 盛水最多的容器

找出柱形图能盛水最多的两个柱子，木桶效应。

主要在于，对盛水最多的理解: 两个柱子需要不断收缩，来找到盛水最多的可能性
如何在O(n)的时间复杂度下，同时不漏掉任何一种情况。

当较短的柱子向前移动，同时发现有value大于当前的情况时，
果断向前移动。且移动后的解就是当前最优解。

因为两个柱子间的距离越来越短，假设短柱子最初是0，移到了5的位置。
那么0-5之间的柱子和小于最长柱子index的值都没有必要比较了。这部分比较可以删掉

因为在移动时，容器的实际高度是0-5之间的柱子高度，长柱子左边的柱子只会减少
容器的宽度，而不会对容器的高度有任何的影响。


## 400 第N个数字

不难，就是有点麻烦，需要找到规律，以9为分界值，1位数有9个，二位数的数字有90个，三位数的数字900个，以此类推。
然后理清边界值条件。主要麻烦的地方应该在go语言，
字符串和数组的相互转换上。当然这就是我用go语言答题的目的，熟悉语法和常见的用法。


## 746 使用最小花费爬楼梯

动态规划问题，每次只能走一步，或者走两步，找出到达楼梯顶的最小值。有一点不同的地方在于，
离楼梯顶只差一步的情况时，可以直接迈上顶部。不需要去加最后一个台阶。
状态转移方程:

result[index]= min {result[index-2]+cost[index],result[index-1]+cost[index]}; index<len(cost)-1
result[index]= min {result[index-2]+cost[index],result[index-1]}; index==len(cost)-1
 
