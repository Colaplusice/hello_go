# leetcode go

## 258 各位相加

你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？

结果只可能是0-9之间的数，那么结果是哪个呢，取余9

## 最大的值
const MaxUint = ^uint(0)
const MinUint = 0
const MaxInt = int(MaxUint >> 1)
const MinInt = -MaxInt - 1

## 11 盛水最多的容器

找出柱形图能盛水最多的两个柱子，木桶效应。

主要在于，对盛水最多的理解: 两个柱子需要不断收缩，来找到盛水最多的可能性
如何在O(n)的时间复杂度下，同时不漏掉任何一种情况。

当较短的柱子向前移动，同时发现有value大于当前的情况时，
果断向前移动。且移动后的解就是当前最优解。

因为两个柱子间的距离越来越短，假设短柱子最初是0，移到了5的位置。
那么0-5之间的柱子和小于最长柱子index的值都没有必要比较了。这部分比较可以删掉

因为在移动时，容器的实际高度是0-5之间的柱子高度，长柱子左边的柱子只会减少
容器的宽度，而不会对容器的高度有任何的影响。


## 400 第N个数字

不难，就是有点麻烦，需要找到规律，以9为分界值，1位数有9个，二位数的数字有90个，三位数的数字900个，以此类推。
然后理清边界值条件。主要麻烦的地方应该在go语言，
字符串和数组的相互转换上。当然这就是我用go语言答题的目的，熟悉语法和常见的用法。


## 746 使用最小花费爬楼梯

动态规划问题，每次只能走一步，或者走两步，找出到达楼梯顶的最小值。有一点不同的地方在于，
离楼梯顶只差一步的情况时，可以直接迈上顶部。不需要去加最后一个台阶。
状态转移方程:

result[index]= min {result[index-2]+cost[index],result[index-1]+cost[index]}; index<len(cost)-1
result[index]= min {result[index-2]+cost[index],result[index-1]}; index==len(cost)-1
 

## 213. 打家劫舍 II

同样的动态规划问题，难点有2:
1. 如果搜了第一间房屋，就不能再搜最后一件房屋。因为他们是环形的。
你不能同时搜连着的两间房屋。所以要分两种情况去计算，第一间搜，和第一间不搜
2. 如何找到最优的搜索路径，在一的约束下。状态转移方程和之前不太一样:
max_value={nums[index]+value[i-2],value[i-1]} 在当前这间房子和
往前两间的最大值加起来。如果最大值超过了前一间的最大值。那么这间房子是值得搜的。
result[i]=nums[i]+result[i-2]的值。否则房子是不值得搜的，result[i]的值就为
result[i-1]的值。 主要是比较难理解吧，加了一个约束条件，我也走了不少弯路。。
  


## 169. 求众数

找出出现次数大于1/2的数  空间O(1) 时间O(n)

遍历所有数，用i记录出现的频率，value代表当前数。result代表要返回的数，
每当遍历到一个数和results不相同时，i-=1.当i减到小于0时，用当前的数来代替
i。最后的结果一定是那个众数。因为只有他大于等于1/2。就算其他数和他交叉
每次都减。最后也是他。



